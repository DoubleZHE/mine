## 类加载

### 一、加载

* 加载指的是**将类的class文件读入到内存**，并**将这些静态数据转换成方法区中的运行时数据结构**，并在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口，这个过程需要类加载器参与

1. 类加载器
   * **启动类加载器**（Bootstrap ClassLoader）
     * 负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。
   * **扩展类加载器**（Extension ClassLoader）
     * 负责加载 JAVA_HOME\lib*.jar 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。
   * **应用程序类加载器**（Application ClassLoader）
   * 自定义类加载器（JVM并没有提供）
     * 应用程序根据自身需要自定义的ClassLoader，需要继承ClassLoader 类。
2. 双亲委派模型
   * **当一个类加载器收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成**。因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
   * 好处：不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象



### 二、连接

* 当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，**连接阶段负责把类的二进制数据合并到JRE中**（意思就是将java类的二进制代码合并到JVM的运行状态之中）。类连接又可分为如下3个阶段

1. 验证

   * 这一阶段的主要目的是**为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求**，并且不会危害虚拟机自身的安全

2. 准备

   * 准备阶段是正式**为类变量分配内存并设置类变量的初始值**阶段，即在**方法区**中分配这些变量所使用的内存空间

   * **注意这里所说的初始值概念**：

     1. 如果一个类变量定义为：

        ~~~java
        public static int v = 8080;
        
        // 实际上变量 v 在准备阶段过后的初始值为 0, 而不是 8080。将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器方法之中。
        ~~~

     2. 如果声明为：

        ~~~java
        public static final int v = 8080;
        
        // 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。
        ~~~

3. 解析

   * **解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程**，
   * 符号引用就是 class 文件中的：
     1. CONSTANT_Class_info
     2. CONSTANT_Field_info
     3. CONSTANT_Method_info
        等类型的常量。
   * **符号引用**：**符号引用与虚拟机实现的布局无关**，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的**符号引用必须是一致的**，因为符号引用的字面量形式**明确定义在 Java 虚拟机规范的 Class 文件格式中**
   * **直接引用**：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在



### 三、初始化

1. 初始化阶段是类加载最后一个阶段，到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
2. JVM规范**并没有规定何时加载类**，但是严格规定了**什么时候必须初始化**：
   1. 类的主动引用（一定会发生类的初始化）
      * 调用类的静态成员（除了final常量），和静态方法
      * java.lang.reflect对类进行反射调用时
      * 初始化子类的时候，父类首先初始化
      * 虚拟机启动时，被执行的主类必须初始化
      * new一个类的对象
   2. 类的被动引用（不会发生类的初始化）
      * 当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过子类引用父类的静态变量时，不会导致子类初始化
      * 通过**数组定义类引用，不会触发此类的初始化**，如 int[] arr=new int[]
      * 引用常量不会发生此类的初始化，**常量在编译阶段就存入常量池了**
3. 初始化顺序
   * **静态变量/静态代码块 -> main方法 -> 非静态变量/代码块 -> 构造方法**
   * 父类–静态变量/父类–静态初始化块
     子类–静态变量/子类–静态初始化块
     父类–变量/父类–初始化块
     父类–构造器
     子类–变量/子类–初始化块
     子类–构造器
4. 卸载
   * 以下情况下，会触发卸载
     * java堆中不存在该类的任何实例。
     * 加载该类的ClassLoader已经被回收
     * 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

## JVM 结构

1. JVM 组成：两个子系统 + 两个组件

   * 两个子系统：Class loader(类装载)、Execution engine(执行引擎)
   * 两个组件：Runtime data area(运行时数据区)、Native Interface(本地接口)。

   ![image-20230406171518690](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230406171518690.png)

   ![](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230406171611035.png)

2. 运行时数据区

   ![image-20230313201838145](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230313201838145.png)

   1. 方法区
      * 用于存储已被Java虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。
      * 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。
      
   2. 堆
      * java虚拟机所管理的内存中最大的一块，在虚拟机**启动时创建**。此内存区域的唯一目的就是**存放对象实例**。所有的对象实例以及**数组都要在堆上分配**
      * java堆是垃圾收集器管理的主要区域，因此也被成为“**GC堆**”
      * java堆可以处于物理上**不连续的内存空间**中。如果堆中没有内存可以完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常
      
   3. 程序计数器
      * 保存**当前线程**所正在执行的字节码指令的地址(行号)
      * 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都有一个独立的程序计数器**，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。
      
   4. Java 虚拟机栈
      * 线程私有的，它的**生命周期和线程相同**
      * 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于**存储局部变量表、操作数栈、动态链接、方法出口**等信息
      * 解析栈帧：
        1. 局部变量表：是用来存储我们临时**8个基本数据类型、对象引用地址、returnAddress类型**。（**returnAddress中保存的是return后要执行的字节码的指令地址**。）
        2. 操作数栈：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去
        3. 动态链接：假如我方法中，有个 service.add()方法，**要链接到别的方法中去**，这就是动态链接，存储链接的地方。
        4. 出口：出口是什呢，**出口正常的话就是return 不正常的话就是抛出异常**
      
   5. 本地方法栈
      * 方法上带了 native 关键字的栈。本地方法栈中就是C和C++的代码
      
        

## Java 堆

1. 堆存放的内容：
   * 对象实例
   * 字符串常量池
     * 原本存放于方法区，jdk1.7 开始放置在堆中
     * 字符串常量池存储的是 String 对象的直接引用，而不是直接存放的对象，是一张 String Table
   * 静态变量：static 修饰的变量，jdk1.7 从方法区移动到堆中
   * 线程分配缓冲区：TLAB
     * 线程私有
2. **堆内存**
   * 分为 新生代（Eden 区 + 2 个 Survivor 区）和 老年代
   * 老年代 和 新生代空间占比是 2 : 1
   * Eden : From Survivor : To Survivor = 8 ：1：1

## 方法区

1. 用于存放 类信息、常量、静态变量、即时编译器编译后的代码等

2. **非堆内存**（JVM 堆以外的 内存）

   1. 对应于 JVM 中的 方法区，也就是 jdk 1.8 的**元空间**

   2. jdk1.8 之前，方法区的实现是 **永久代**（PermSpace）

   3. 演变过程：

      ![image-20230709222732530](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230709222732530.png)

3. **为什么用 元空间 替换 永久代**

   * 为永久代设置最大空间大小是难以确定的
   * 在某些场景下，如果动态加载类过多，容易产生永久代的 OOM（内存溢出）
   * 而元空间和永久代之间最大的区别在于：元空间 并不在 JVM 中，而是**使用本地内存**。因此，默认情况下，**元空间的最大大小仅受本地内存限制**
   * 对永久代进行调优是很困难的

4. 为什么要移动字符串常量池的位置

   * 因为永久代的回收效率很低，在 Full GC 时才会触发，这导致字符串常量池回收效率不高
   * 而我们在开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足
   * 将字符串常量池移动到堆里，能及时回收内存



## Java 对象

1. 对象的创建过程

   1. 类是否加载
      * 判断类是否已经被加载，没有先加载类，详见类的加载过程

   2. 内存是否规整

      * 规整：采用**指针碰撞**
        * 如果Java堆内存是规整，**即所有用过的内存放在一边，而空闲的的放在另一边**。分配内存时**将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离**，这样便完成分配内存工作

      * 不规整：采用**空闲列表**
        * 如果Java堆的内存不是规整的，则需要由虚拟机**维护一个列表来记录那些内存是可用的**，这样在分配的时候可以**从列表中查询到足够大的内存分配给对象**，并在分配后更新列表记录

   3. 并发处理，解决并发问题

        * 对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方法：

          1. **CAS同步处理**
            * 采用 CAS + 失败重试来保障更新操作的原子性

          2. **本地线程分配缓存（TLAB）**
             * 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过 -XX:+/-UserTLAB 参数来设定虚拟机是否使用 TLAB


   4. 对象初始化

2. **对象的访问定位**
   * **句柄访问**：堆中划分一个句柄池，引用中存储对象的句柄地址，句柄中包含**对象实例数据**和**对象类型数据**的两个指针。优点是稳定的句柄地址，对象移动时只需改变实例数据指针，引用本身不用修改
   * **直接指针访问**：引用存储的直接是**对象的实例数据**指针，对象实例数据中**包含了对象类型数据指针**。优点是速度更快，节省了一次指针定位的时间。HotSpot采用该方法

3. **深拷贝和浅拷贝**

   * 浅拷贝：只是增加了一个指针指向已经存在的内存地址
   * 深拷贝：增加一个指针，并申请一块新的内存，使这个增加的指针指向这个新的内存
   * 使用深拷贝时，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误
   * 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那浅复制出来的对象也会相应的改变
   * 深复制：在计算机中开辟一块**新的内存地址**用于存放复制的对象

4. 计算**对象的内存**占用

   1. 计算方式：
      * 对象头 12 字节
      * 每个基本数据类型的属性按大小计算
      * 合计后，按照 4 字节对齐（也就是结果必须是 4 的 倍数），添加 1 - 4 字节

5. **引用类型**

   * **强引用**：发生 GC 时不会被回收

     * 平时 new 一个对象就是强引用，例如：

       ~~~java
       Object obj = new Object();
       ~~~

       即使在内存不足的情况下，JVM 宁愿 OutOfMemory 错误也不会回收这种对象

   * **软引用**：有用但不是必须的对象，在发生内存溢出之前会被回收

     * 如果一个对象只具有软引用，则内存足够时，GC 时不回收；内存不足时，GC 回收

       ~~~java
       SoftReference<String> softRef = new SoftReference<String>(str);
       ~~~

     * 用处：例如**浏览器的后退按钮**

   * **弱引用**：有用但不是必须的对象，在下一次 GC 时会被回收

     * ThreadLocalMap 中使用过 弱引用

   * **虚引用**：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 GC 时返回一个通知


## 垃圾回收

1. JVM 垃圾回收机制

   * 程序在运行过程中，会产生大量的内存垃圾（一些没有引用指向的内存对象都属于内存垃圾，因为这些对象已经无法访问，程序用不了它们了，对程序而言它们已经死亡），为了确保程序运行时的性能，java虚拟机在程序运行的过程中不断地进行自动的垃圾回收（GC）

2. 新生代、老年代、永久代（方法区）

   * 堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )
   * 老年代就一个区域。新生代 ( Young ) 又被划分为三个区域：**Eden、From Survivor、To Survivor**
   * **默认的**，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 **1:2** ( 该值可以通过参数 **–XX:NewRatio** 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小
   * 默认的，Edem ： From Survivor ： To Survivor = **8 : 1 : 1** ( 可以通过参数 **–XX:SurvivorRatio** 来设定 )
   * JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，**总是有一块 Survivor 区域是空闲着的**。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间
   * **永久代就是JVM的方法区**。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收

3. 为什么要这样分代

   * 可以根据各个年代的特点进行对象分区存储，更便于回收，采用最适当的收集算法：
     1. 新生代中，每次垃圾收集时都发现大批对象死去，只有少量对象存活，便采用了复制算法，只需要付出少量存活对象的复制成本就可以完成收集
     2. 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法
   * 数据会**首先分配到 Eden 区当中**（当然也有特殊情况，如果是**大对象那么会直接放入到老年代**（**大对象是指需要大量连续内存空间的 java 对象**）。**当 Eden 没有足够空间的时候**就会触发 JVM 发起一次**Minor GC**，。如果对象经过一次 Minor-GC 还存活，**并且又能被Survivor 空间接受，那么将被移动到 Survivor 空间当中**。并将其年龄设为1，对象在 Survivor **每熬过一次 Minor GC，年龄就加 1**，当年龄达到一定的程度（**默认为 15**）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的

4. **判断对象是否存活**

   1. **引用计数器法**
      * 引用计数法就是**如果一个对象没有被任何引用指向**，则可视之为垃圾。这种方法的**缺点**就是它**很难解决对象之间相互循环引用的问题**（**循环引用**）
      * 什么是引用计数法：每个对象在创建的时候，就给这个对象绑定一个计数器。每当有一个引用指向该对象时，计数器加一；每当有一个指向它的引用被删除时，计数器减一。这样，当没有引用指向该对象时，计数器为0就代表该对象死亡
      * **主流 JVM 没有选用该方法**
   2. **可达性分析法**
      * 从GC Roots开始向下搜索，搜索所走过的路径为引用链。当一个对象到GC Roots没用任何引用链时，则证明此对象是不可用的，表示可以回收
      * 可作为 GC Roots 的对象：
        1. JVM 在进行垃圾回收时，需要寻找垃圾对象，是采用 **可达性分析法** 来判断对象是否可以回收，可达性分析法是从 GC Roots 开始向下搜索，搜索所走过的路程为引用链，如果一个对象到GC Roots 没有任何引用链，则该对象是不可用的，可以被回收。
        2. 因此 能作为 GC Roots 的有一个特征，它只会引用其他对象，而不会被其他对象引用，例如：**栈中的本地变量、方法区的静态变量、本地方法栈中的变量、正在运行的线程 等可以作为 GC Roots**
      * 主流 JVM 采用该方法

5. **GC 算法**

   1. **标记-清除** 算法
      * 为每个对象**存储一个标记位**，记录对象的状态（活着或是死亡）。
        分为两个阶段，一个是**标记阶段**，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是**清除阶段**，该阶段对死亡的对象进行清除，执行 GC 操作
      * 优点：
        1. 可以解决**循环引用**
        2. 必要时才回收(内存不足时)
      * 缺点：
        1. 回收时，**应用需要挂起**，也就是stop the world
        2. 标记和清除的**效率不高**，尤其是要扫描的对象比较多的时候
        3. 会造成**内存碎片**(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)
      * 应用场景：一般应用于**老年代**，因为老年代的对象生命周期比较长
   2. **标记-整理** 算法
      * 标记-清除法的一个**改进版**。同样，在**标记阶段**，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法**并没有直接对死亡的对象进行清理**，而是**将所有存活的对象整理一下，放到另一处空间**，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。
      * 优点：
        1. 解决标记清除算法出现的内存碎片问题
      * 缺点：
        1. 压缩阶段，由于移动了可用对象，需要去更新引用
      * 应用场景：一般应用于**老年代**,因为老年代的对象生命周期比较长
   3. **复制** 算法
      * 将**内存平均分成两部分**，然后每次只使用其中的一部分，**当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中**，然后将之前的内存清空，只使用这部分内存，循环下去
      * 与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内
      * 优点：
        1. 在存活对象不多的情况下，**性能高**，能**解决内存碎片**和java垃圾回收算法之-标记清除 中导致的**引用更新**问题
      * 缺点：
        1. 会**造成一部分的内存浪费**。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，复制算法的性能会变得很差
      * 应用场景：
        1. 复制算法一般是使用在**新生代**中，因为新生代中的对象一般都是朝生夕死的，存活对象的数量并不多，这样使用复制算法进行拷贝时效率比较高
        2. 将新生代划分为Eden与2块Survivor Space(幸存者区) ，然后**在Eden –>Survivor Space 与To Survivor之间实行复制算法**
        3. jvm在应用复制算法时，**并不是把内存按照1:1来划分的**，这样太浪费内存空间了。一般的 jvm 都是 8:1。也即是说，Eden区 : From区 : To区域的比例是始终有**90%的空间是可以用来创建对象的,而剩下的10%用来存放回收后存活的对象**
   4. 分代 算法
      * **根据对象的存活周期**的不同将内存划分成几块，新生代和老年代，这样就可以**根据各个年代的特点采用最适当的收集算法**
      * 在**新生代**，每次垃圾收集器都发现有大批对象死去，只有少量存活，采用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集
      * **老年代**中因为对象存活率高、没有额外空间对它进行分配担保，就必须**标记清除**法或者标记整理算法进行回收

6. 垃圾回收器

   * 垃圾收集器是**垃圾回收算法**（引用计数法、标记清楚法、标记整理法、复制算法）**的具体实现**，不同垃圾收集器、不同版本的JVM所提供的垃圾收集器可能会有很在差别

     ![image-20230313212107597](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230313212107597.png)

   * 分类：

     1. 新生代收集器：Serial、ParNew、Parallel Scavenge
     2. 老年代收集器：CMS、Serial Old、Parallel Old
     3. 整堆收集器：G1

   * 详情

     1. Serial

        * 新生代、单线程、复制算法

        * 只会使用一个 CPU 或者线程去完成垃圾收集工作，而且在它进行垃圾收集时，**必须暂停其他所有的工作线程**，直到它收集结束

        * **简单高效**，适合单 CPU 环境。单线程没有线程交互的开销，因此**拥有最高的单线程收集效率**

        * 使用方式

          ~~~java
          "-XX:+UseSerialGC" 
          ~~~

     2. ParNew

        * 新生代、多线程、复制算法

        * Serial 多线程版本，除了多线程外，其他行为、特点与 Serial 一样

        * **只有它能与 CMS 配合使用**

        * 但在单个CPU环境中，不比Serail收集器好，多线程使用它比较好

          ~~~java
          设置垃圾收集器："-XX:+UseParNewGC"  --强制指定使用ParNew；    
          设置垃圾收集器： "-XX:+UseConcMarkSweepGC"  --指定使用CMS后，会默认使用ParNew作为新生代收集器；
          设置垃圾收集器参数："-XX:ParallelGCThreads"  --指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；
          ~~~

     3. Parallel Scavenge

        * 新生代、多线程、复制算法

        * 与ParNew 不同的是：**高吞吐量**为目标，（**减少垃圾收集时间**，让用户代码获得更长的运行时间）

          ~~~java
          设置垃圾收集器："-XX:+UseParallelGC"  --添加该参数来显式的使用改垃圾收集器；
          设置垃圾收集器参数："-XX:MaxGCPauseMillis"  --控制垃圾回收时最大的停顿时间(单位ms)
          设置垃圾收集器参数："-XX:GCTimeRatio"  --控制程序运行的吞吐量大小吞吐量大小=代码执行时间/(代码执行时间+gc回收的时间)
          设置垃圾收集器参数："-XX:UseAdaptiveSizePolicy"  --内存调优交给虚拟机管理
          ~~~

     4. Serial Old

        * 老年代、单线程、标记-整理 算法

        * Serial 老年代版本

          ~~~java
          在JDK1.5及之前，与Parallel Scavenge收集器搭配使用，
          在JDK1.6后有Parallel Old收集器可搭配。
          现在的作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用
          ~~~

     5. Parallel Old

        * 老年代、多线程、标记-整理 算法

        * 在单个CPU环境中，不比Serial Old收集器好，多线程使用它比较好

          ~~~java
          设置垃圾收集器："-XX:+UseParallelOldGC"：指定使用Parallel Old收集器；
          ~~~

     6. CMS

        * 老年代、**标记-清除 算法**

        * 一种以**获取最短回收停顿时间为目标**的收集器，适用于互联网站或者 **B/S 系统的服务端**上。

        * **并发收集、低停顿**。垃圾收集线程与用户线程（基本上）可以**同时工作**

        * 缺点：

          1. 对CPU资源非常敏感
          2. 无法处理浮动垃圾，可能出现"Concurrent Mode Failure"失败
          3. 产生大量内存碎片

        * 步骤：

          1. 初始标记：标记GC Roots 能直接关联到的对象
          2. 并发标记：进行GC Roots Tracing
          3. 重新标记：修正并发标记期间的变动部分
          4. 并发清除

          ~~~java
          设置垃圾收集器："-XX:+UseConcMarkSweepGC"：指定使用CMS收集器；
          ~~~

     7. G1

        * G1 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比于 CMS 收集器，G1 收集器两个最突出的改进是：
          * 基于标记-整理算法，不产生内存碎片
          * 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
        * G1 收集器 **避免全区域垃圾收集**，它把**内存划分为大小固定的几个独立区域**，并且跟踪这些区域的垃圾收集进度，同时在**后台维护一个优先级列表**，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级垃圾回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率
        * 特点：
          * **无分代**：G1 将新生代、老年代的物理空间划分取消了。这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够
          * **标记-整理 算法**：无内存碎片产生
          * **分区回收**：G1 虽然没有了新生代与老年代的物理限制，但是 G1 采取内存分区策略，将堆内存划分为大小固定的几个独立区域。在分区中，同时存在新生代与老年代

7. 常用的 JVM 配置

   * 配置参数

     ~~~java
     -Xms：初始堆大小，JVM 启动的时候，给定堆空间大小
     -Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。 
     -Xmn：设置堆中年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。 
     -XX:NewSize=n 设置年轻代初始化大小大小 
     -XX:MaxNewSize=n 设置年轻代最大值
     -Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。
     -XX:MaxTenuringThreshold=n 设置年轻带垃圾对象最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。
     ~~~

   * 在哪里设置

     1. 单项目应用

        * Run -> Edit Configurations -> VM options (新版本的idea 中需要点击右上角的 Modify options -> add VM options)

     2. 全局配置

        1. 找到IDEA安装目录中的 bin 目录
        2. 找到 idea.exe.vmoptions 文件
        3. 打开该文件编辑并保存

     3. war （Tomcat）包

        * 修改 Tomcat 的 JVM 参数

        * Windows 下就是文件 /bin/**catalina.bat**，增加设置：JAVA_OPTIONS，如 set “JAVA_OPTIONS=-Xms512M -Xmx1024M”

        * Linux 下，tomcat 的 bin 目录下 catalina.sh 添加

          ~~~shell
          注意：位置要在cygwin=false前
          JAVA_OPTS="-Xms512M -Xmx1024M ...等等等 JVM参数"
          ~~~

     4. Jar 包，在 java -jar 后面插入 JVM 命令

## JVM 调优

1. 调优案例：metaspace (元空间) 导致频繁FGC问题（服务环境：ParNew + CMS + JDK8）

   1. 首先查看GC日志，发现出现FGC的原因是metaspace空间不够。对应的 GC 日志：

      ~~~java
      Full GC (Metadata GC Threshold)
      ~~~

   2. 进一步查看日志发现元空间存在内存碎片化现象。对应的 GC 日志：

      ~~~java
      Metaspace       used 35337K, capacity 56242K, committed 56320K, reserved 1099776K
      ~~~

      参数意义：

      * used ：已使用的空间大小
      * capacity：当前已经分配且未释放的空间容量大小
      * committed：当前已经分配的空间大小
      * reserved：预留的空间大小

      解析：元空间的分配以 **chunk** 为单位，当一个 ClassLoader 被垃圾回收时，所有属于它的空间（chunk）被释放，此时该 chunk 称为 Free Chunk，而 committed chunk 就是 capacity chunk 和 free chunk 之和

      ![image-20230313231141082](https://gitee.com/swlfox/picture-bed/raw/master/Img/image-20230313231141082.png)

      之所以说**内存存在碎片化现象**就是**根据 used 和 capacity 的数据得来的**，上面说了元空间的分配以 chunk 为单位，即使一个 ClassLoader 只加载1个类，也会独占整个 chunk，所以**当出现 used 和 capacity 两者之差较大的时候，说明此时存在内存碎片化的情况**

      元空间主要适用于存放类的相关信息，而存在内存碎片化说明很可能创建了较多的类加载器，同时使用率较低。

      因此，**当元空间出现内存碎片化时，我们会着重关注是不是创建了大量的类加载器**

   3. 通过 dump 堆存储文件发现存在大量 DelegatingClassLoader：

      * 通过进一步分析，发现是由于反射导致创建大量 DelegatingClassLoader。其核心原理如下：
        * 在 JVM 上，最初是通过 JNI 调用来实现方法的反射调用，当 JVM 注意到通过反射经常访问某个方法时，它将生成字节码来执行相同的操作，称为膨胀（inflation）机制。如果使用字节码的方式，则会为该方法生成一个 DelegatingClassLoader，**如果存在大量方法经常反射调用，则会导致创建大量 DelegatingClassLoader**

   4. 反射调用频次达到多少才会从 JNI 转字节码？

      * 默认是**15次**，可通过参数 **-Dsun.reflect.inflationThreshold** 进行控制，在小于该次数时会使用 JNI 的方式对方法进行调用，如果调用次数超过该次数就会使用字节码的方式生成方法调用。

      * 分析结论：反射调用导致创建大量 DelegatingClassLoader，占用了较大的元空间内存，同时存在内存碎片化现象，导致元空间利用率不高，从而较快达到阈值，触发 FGC。

      * **优化策略**：
        1. 适当调大 metaspace 的空间大小。
        2. 优化不合理的反射调用。例如最常见的属性拷贝工具类 BeanUtils.copyProperties 可以使用 mapstruct 替换

2. JVM 可视化工具

   1. visual VM
      * 提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析
      * 位置：JDK 根目录的 bin 文件夹下的 visualvm.exe
   2. jconsole
      * JConsole 是一个内置 Java 性能分析器，可以从命令行或在 GUI shell 中运行。您可以轻松地使用 JConsole来监控 Java 应用程序性能和跟踪 Java 中的代码
      * jdk/bin 目录下面的 jconsole.exe

   



