## 保证 Redis 和 MySQL 的数据一致性

Redis 是用来实现应用和数据库之间的一个读操作的缓存层，主要目的是去减少数据库的 IO，还可以提升数据的 IO 性能。

整体架构如下：

![Redis 应用整体架构](../../../ImageRepository/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/Redis%20%E5%BA%94%E7%94%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png)

在如此架构下，可能会出现一份数据同时保存在 Redis 和 MySQL 中，当数据发生变化时需要同时去更新 Redis 和 MySQL，由于更新操作是有先后顺序的，并且不拥有 MySQL 中的多表事务操作可以满足 ACID 的特性，所以就会出现一个数据一致性的问题。

- 先更新数据库再更新缓存：如果缓存更新失败就会导致数据库和 Redis 中的数据不一致

  ![数据一致性-更新缓存失败](../../../ImageRepository/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7-%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E5%A4%B1%E8%B4%A5.png)

- 先删除缓存再更新数据库：理想状态下，下次应用访问数据时，发现 Redis 缓存为空，就会去数据库中查询数据，并将数据保存到 Redis 缓存中。
  
  ![先删除缓存再更新数据库](../../../ImageRepository/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93.png)

**极端情况下，由于删除 Redis 缓存和更新数据库这两个操作并不是原子操作，如果出现其他线程来访问，还是会出现数据不一致的问题。所以如果需要在极端情况下仍然保证数据一致性就只能采用最终一致性的一个方案。**

[先删除缓存再更新数据库-极端情况下的实现](#数据最终一致性)

### 数据最终一致性

- 基于 RocketMQ 的可靠性消息通信来实现数据的最终一致性

![基于 RocketMQ 的可靠性消息通信实现数据一致性](../../../ImageRepository/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E4%BA%8E%20RocketMQ%20%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png)

- 直接通过 Canal 组件监控 MySQL 中 binlog 的日志，把更新后的数据同步到 Redis 里面

> 因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那么就不能使用这样的一个方案来实现