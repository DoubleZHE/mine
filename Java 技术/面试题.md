# JavaSE

## 集合

### Java 集合可分为 Collection 和 Map 两种体系

- Collection 接口：单列数据，定义了存取一组对象的方法的集合，用来存储一个一个的对象。
	- List：存储有序、可重复的数据。
		- ArrayList：作为 List 接口的主要实现类。当随机访问 List 时（get 和 set 操作），效率高，但线程不安全。底层使用 Object[] elementData 存储。
		- LinkedList：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高。底层使用双线链表存储。
		- Vector：作为 List 接口的古老实现类。线程安全，但效率低。底层使用 Object[] elementData 存储。
	- Set：存储无序的、不可重复的数据。
		- HashSet：作为 set 接口的主要实现类。线程不安全。可以存储 NULL 值。底层采用数组 + 链表的结构。
			- LinkedHashSet：作为 HashSet 的子类。遍历器内部数据时，可以按照添加的顺序遍历。
		- TreeSet：可以按照添加对象的指定属性进行排序

> 无序性：不等于随机性，存储的数据在底层数组中，并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。<br>
> 不可重复性：保证添加的元素按照 equals() 判断时，不能返回 true。即相同的元素只能添加一个。

- Map 接口：双列数据，保存具有 `key - value 对` 的集合。
	- HashMap：作为 Map 的主要实现类。线程不安全，效率高。能存储 NULL 的 key 和 value。
		- LinkedHashMap：保证在遍历 Map 元素时可以按照添加的顺序实现遍历。<br>
		原因：在原有的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。<br>
		对于频繁的遍历操作，此类执行效率高于 HashMap。
	- TreeMap：保证按照添加的 `key - value` 键值对进行排序，实现排序遍历。此时考虑 key 的自然排序或者定制排序。底层使用红黑树。
	- Hashtable：作为古老的实现类。线程安全，效率低。不能存储 NULL 的 key 和 value。
		- Properties：常用于处理配置文件。key 和 value 都是 String 类型。

> HashMap 的底层：<br>
> JDK 7 以及之前版本：数组 + 链表<br>
> JDK 8：数组 + 链表 + 红黑树

> Map 结构的理解：<br>
> Map 中的 key：无序的、不可重复的。使用 Set 存储所有的 key --> key 所在的类要重写 `equals()` 和 `hashCode()`（以 HashMap 为例）<br>
> Map 中的 value：无序的、可重复的。使用 Collection 存储所有的 value --> value 所在的类要重写 `equals()`<br>
> 一个键值对：key - value 构成了一个 entry 对象。<br>
> Map 中的 entry：无序的、不可重复的。使用 Set 存储所有的 entry。<br>

### 如何区分 List 中 remove(int index) 和 remove(Object obj)？

```java
@Test
public void testListRemove() {
	List list = new ArrayList();
	list.add(4);
	list.add(3);
	list.add(2);
	list.add(1;
	updateList1(list);
	System.out.println(list);
	updateList2(list);
	System.out.println(list);
}

private void updateList1(List list) {
	list.remove(3);	// 索引值 index = 3，输出结果为 [4, 3, 1]
}

private void updateList2(List list) {
	list.remove(new Integer(3));	//对象 value = 2，输出结果为 [4, 1]
}
```

`List.remove(Object obj)`：以对象方式删除指定元素

`List.remove(int index)`：删除指定索引位置的元素

> 一般来说，采用索引方式删除效率会更高；
> 对象方式删除需要遍历列表，索引删除只需要检查索引合法。

### ArrayList 和 LinkedList 的区别

- ArrayList、LinkedList 都是 List 接口实现而来的，存储数据的特点是相同的，都是存储有序的、可重复的数据。
- 一个是 Array（动态数组）的数据结构，相当于动态数组；另一个是Link（链表）的数据结构，底层使用双向链表结构，也可当作堆栈、队列、双端队列。
- ArrayList 作为 List 接口的主要实现类。当随机访问 List 时（get 和 set 操作），ArrayList 比 LinkedList 的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。但 ArrayList 线程不安全。
- LinkedList 对于频繁的插入、删除操作，使用效率比 ArrayList 高

### 为什么说 ArrayList 线程不安全？

首先看 ArrayList 源码

```java
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
		
    //默认的数组容量
    private static final int DEFAULT_CAPACITY = 10;

    ...
	
    //存放数据的底层数组，使用 transient 关键字不序列化某个变量
    transient Object[] elementData;

    //记录当前 ArrayList 的大小（它包含的元素数）。
    private int size;
  
  	...

	/**
	 * 将指定的元素追加到此列表的末尾。
	 * 添加一个元素时，做了如下两个操作：
	 * 1. 判断列表的 capacity 容量是否足够，是否需要扩容
	 * 2. 将元素放在列表的元素数组里面
	 */
   	public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // 这里会判断容量是否充足，不充足需要扩容
        elementData[size++] = e;
        return true;
    }
}
```

ArrayList 底层使用 `Object[] elementData 数组` 实现，用来保存所有的元素，以及一个 size 变量用来保存当前数组中已经添加了多少元素。

- 在多个线程进行 add 操作时可能会导致 elementData 数组越界

	ArrayList 默认数组大小为 10。假设现在已经添加进去 9 个元素了，size = 9。
	1.  线程 A 执行完 add 函数中的`ensureCapacityInternal(size + 1)`挂起了。
	2.  线程 B 开始执行，校验数组容量发现不需要扩容。于是把 "b" 放在了下标为 9 的位置，且 size 自增 1。此时 size = 10。
	3.  线程 A 接着执行，尝试把 "a" 放在下标为 10 的位置，因为 size = 10。但因为数组还没有扩容，最大的下标才为 9，所以会抛出数组越界异常 `ArrayIndexOutOfBoundsException`

	主要看这段代码：
	
	```java
	elementData[size++] = e;
	```
	
	不是一个原子操作，是分两步执行的，可拆分为：
	
	```java
	elementData[size] = e;
	size++;
	```

	情况一（size 不达标）：
	
	> 代码中有两个线程，假设为 t1 和 t2，有 ArrayList size=5（即其中有5个元素）。elementData.length=10<br>
	> t1 进入 add() 方法，这时获取到 size 值为 5，调用 ensureCapacityInternal() 方法判断容量是否需要扩容<br>
	> t2 也进入 add() 方法，这时获取到 size 值也为 5，也调用 ensureCapacityInternal() 方法判断容量是否需要扩容<br>
	> t1 发现自己的需求为 size+1=6，容量足够，无需扩容<br>
	> t1 发现自己的需求为也 size+1=6，容量足够，无需扩容<br>
	> t1 开始设置元素操作，`elementData[size] = e`，成功，<br>
	> t2 也开始设置元素操作，`elementData[size] = e`，成功，注意此时 t1 的 size+1 还没执行<br>
	> t1 size = size + 1 = 6，暂未写入主存<br>
	> t2 size = size + 1 此时因为 t1 操作完 size 还未写入主存，所以 size 依然为5，+1 后仍为 6<br>
	> t1 将 size=6 写入主存<br>
	> t2 将 size=6 写入主存<br>
	> 这样，size=6 比预期结果小了。

	情况二（size 达标）：

	> 代码中有两个线程，假设为 t1 和 t2，有 ArrayList size=5（即其中有 5 个元素）。elementData.length=10<br>
	> t1 进入 add()方法，这时获取到 size 值为 5，调用 ensureCapacityInternal() 方法判断容量是否需要扩容<br>
	> t2 也进入 add()方法，这时获取到 size 值也为 5，也调用ensureCapacityInternal()方法判断容量是否需要扩容<br>
	> t1 发现自己的需求为 size+1=6，容量足够，无需扩容<br>
	> t1 发现自己的需求为也 size+1=6，容量足够，无需扩容<br>
	> t1 开始设置元素操作，`elementData[size] = e`，成功，<br>
	> t2 也开始设置元素操作，`elementData[size] = e`，成功，注意此时 t1 的 size+1 还没执行<br>
	> t1 size = size + 1 = 6，并写入主存<br>
	> t2 size = size + 1 = 7<br>
	> 这样，size 符合预期，但是 t2 设置的值被覆盖，而且索引为 6 的位置将永远为 null，因为 size 已经为7，下次 add() 也会从 7 开始。除非手动 set 值。

- 当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值

	依然看这段代码：
	
	```java
	elementData[size++] = e;
	```
	
    单线程执行这段代码完全没问题，可是到多线程环境下可能就有问题了，可能一个线程会覆盖另一个线程的值，逻辑如下：
        1. 列表为空 size = 0。
            2. 线程 A 执行完 `elementData[size] = e;`之后挂起。A 把 "a" 放在了下标为 0 的位置。此时 size = 0。
            3. 线程 B 执行 `elementData[size] = e;` 因为此时 size = 0，所以 B 把 "b" 放在了下标为 0 的位置，于是刚好把 A 的数据给覆盖掉了。
            4. 线程 B 将 size 的值增加为 1。
            5. 线程 A 将 size 的值增加为 2。
    这样子，当线程 A 和线程 B 都执行完之后理想情况下应该是 "a" 在下标为 0 的位置，"b" 在标为 1 的位置。而实际情况确是下标为 0 的位置为 "b"，下标为 1 的位置啥也没有。

### 如何解决 ArrayList 线程不安全

1. 将 ArrayList 替换成 Vector

	```java
	Vector<Integer> arrayList = new Vector<>();
	```
	
	Vector是线程安全的，我们可以看下Vector底层的方法是同步的（Synchronized修饰），从而可以解决ArrayList线程不安全的问题
	
	```java
	/**
	 * Appends the specified element to the end of this Vector.
	 * 将指定的元素追加到此 Vector 的末尾。
	 *
	 * @param e element to be appended to this Vector
	 * @return {@code true} (as specified by {@link Collection#add})
	 * @since 1.2
	 */
	public synchronized boolean add(E e) {
	    modCount++;
	    ensureCapacityHelper(elementCount + 1);
	    elementData[elementCount++] = e;
	    return true;
	}
	```

2. 使用 Collections.synchronizedList()

	```java
	List<Integer> arrayList = Collections.synchronizedList(new ArrayList<>());
	```
	
	`Collections.synchronizedList()` 方法中会这个根据传入的 List 是否实现 RandomAccess 这个接口来返回的 SynchronizedRandomAccessList 还是 SynchronizedList.
	
	```java
	public static <T> List<T> synchronizedList(List<T> list) {
	return (list instanceof RandomAccess ?
	        new SynchronizedRandomAccessList<>(list) :
	        new SynchronizedList<>(list));
	}
	```

3. 使用 CopyOnWriteArrayList

	```java
	List<Integer> arrayList = new CopyOnWriteArrayList<>();
	```
	
	CopyOnWriteArrayList是一个线程安全的ArrayList,其实现原理是读写分离，其对写操作使用ReentrantLock来上锁，对读操作则不加锁；CopyOnWriteArrayList在写操作的时候，会将list中的数组拷贝一份副本，然后对其副本进行操作（如果此时其他线程需要读的事，那么其他线程读取的是原先的没有修改的数组，如果其他写操作的线程要进行写操作，需要等待正在写的线程操作完成，释放ReentrantLock后，去获取锁才能进行写操作），写操作完成后，会讲list中数组的地址引用指向修改后的新数组地址。
	
	如果使用场景的写操作十分频繁的话，建议还是不要实现 CopyOnWriteArrayList，因为其添加的时候会造成数组的不断扩容和复制，十分消耗性能，会消耗内存，如果原数组的数据比较多的情况下，可能会导致 Young GC 或者 Full GC；并且其不能使用在实时读的场景，在写操作过程中是要花费时间的，读取的时候可能还是旧数据；
	CopyOnWriteArrayList 合适读多写少的场景， 如果我们在使用的时候没法保证 CopyOnWriteArrayList 到底要放多少数据的话，我们还是要谨慎使用，如果数据稍微有点多，每次写操作都重新拷贝数组，其代价实在太高昂了。

> 一和二两种方法都是将所有的方法都加锁，那会导致效率低下，只能一个线程操作完，下一个线程获取到锁才能操作。
> CopyOnWriteArrayList 由于写时进行复制，内存里面同时存在两个对象占用内存，如果对象过大容易发送 YoungGc 和 FullGc，如果使用场景的写操作十分频繁的话，建议还是不要实现CopyOnWriteArrayList。

### HashMap的底层实现原理（烂大街面试题）（以JDK 7为例说明）

`HashMap map = new HahsMap();`<br>
在实例化以后，底层创建了长度是 16 的一维数组 `Entry[] table`。<br>
…<br>
可能已经执行过多次 `put()`<br>
…<br>
`map.put(key1, value1);`<br>
首先调用所在类的 `hashCode()` 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到在 Entry 数组中的存放位置。<br>
如果此位置上的数据为空，此时的 key1-value1（实际上是 Entry[0]）添加成功。 --> 情况 1<br>
如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据【以链表形式存在】），比较 key1 和已经存在的一个或多个数据的哈希值：<br>
&emsp;如果 key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功。 --> 情况 2<br>
&emsp;如果 key1 的哈希值与已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用 key1 所在类的 equals(key2) 方法，比较：<br>
&emsp;&emsp;如果 equals() 返回 false：此时 key1-value1 添加成功。  --> 情况 3<br>
&emsp;&emsp;如果 equals() 返回 true：使用 value1 替换 value2<br>

> 补充：关于情况 2 和情况 3：此时 key1-value1 和原来的数据以链表的方式存储。

在不断的添加过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，默认的扩容方式：扩容为原来的2倍，并将原有的数据复制过来。

#### JDK 8 相较于 JDK 7 在底层实现方面的不同：

1. `new HashMap()` 时底层没有创建一个长度为 16 的数组
2. JDK 8 底层的数组是：`Node[]`，而非 `Entry[]`
3. 首次调用 `put()` 方法时，底层创建长度为 16 的数组
4. 原来 JDK 7 底层结构只有：数组 + 链表。JDK 8 底层结构：数组 + 链表 + 红黑树。<br>
当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64 时，此时此索引位置上的所有数据改为用红黑树存储

> ![HashMap 源码中的重要常量](https://gitee.com/DoubleZHEz/mine/raw/master/ImageRepository/Java%20%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/HashMap%20%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8F.png)

### iterator 迭代器接口

> 设计模式的一种（对象行为型模式），主要用于遍历 Collection 集合中的元素。<br>
> 提供一种方法顺序访问一个聚合对象中的各个对元素，而又不需要暴露该对象的内部表示。

iterator 迭代器接口源码如下：
```java
public interface Iterator<E> {  
    /**  
     * 如果迭代有更多元素，则返回true。（换句话说，如果next将返回元素而不是抛出异常，则返回true。）
     */
    boolean hasNext();  
  
    /**  
     * 返回迭代中的下一个元素。
     */
	E next();  

	/**  
     * 从基础集合中删除此迭代器返回的最后一个元素（可选操作）。每次调用 next 时只能调用此方法一次。如果在迭代过程中以调用此方法以外的任何方式修改了基础集合，则迭代器的行为未指定。
     * 抛出:
		UnsupportedOperationException：如果此迭代器不支持删除操作
		IllegalStateException：如果尚未调用下一个方法，或者在上一次调用下一方法之后已经调用了 remove方法
     * 实现：默认实现抛出 UnsupportedOperationException 实例
     * 要求:不执行其他操作。
     */
    default void remove() {  
        throw new UnsupportedOperationException("remove");  
    }  

	/**  
     * 对每个剩余元素执行给定的操作，直到所有元素都已处理完毕或该操作引发异常。如果指定了迭代顺序，则按迭代顺序执行操作。由操作引发的异常被转发给调用者。
     * 形参：action–每个元素要执行的操作
     * 抛出：
		NullPointerException：如果指定的操作为空
     * 实现 
     * 要求：默认实现行为 while (hasNext()) action.accept(next());`
     */
    default void forEachRemaining(Consumer<? super E> action) {  
        Objects.requireNonNull(action);  
        while (hasNext())  
            action.accept(next());  
    }  
}
```

在调用 it.next() 方法之前必须要调用 it.hasNext() 进行检测。若不调用，且 下一条记录无效，直接调用 it.next() 会抛出 NoSuchElementException 异常。

![迭代器执行原理](https://gitee.com/DoubleZHEz/mine/raw/master/ImageRepository/Java%20%E6%8A%80%E6%9C%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png)

## 线程

# 框架

## Spring

### IOC

   1. 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理

   2. 使用 IOC 目的：为了耦合度降低

> [IOC 概念和原理](Java%20技术/框架/SSM%20框架/Spring%205.md#^f92f57)

### AOP

## Spring MVC

### Spring MVC 的工作流程

用户通过视图层发送请求到服务器,在服务器中请求被 Controller 接收,Controller 调用相应的 Model 层处理请求,处理完毕将结果返回到 Controller,Controller 再根据请求处理的结果找到相应的 View 视图,渲染数据后最终响应给浏览器

> [Spring MVC 的工作流程](Java%20技术/框架/SSM%20框架/SpringMVC.md#^4ab29b)

## MyBatis

### 为什么项目使用 Mybatis 作为持久层框架？

MyBatis框架的优点：

-   与JDBC相比，减少了50%以上的代码量。
-   MyBatis是最简单的持久化框架，小巧并且简单易学。
-   MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用。
-   提供XML标签，支持编写动态SQL语句（XML中使用if, else）。
-   提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。

MyBatis框架的缺点：

-   SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。
-   SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

